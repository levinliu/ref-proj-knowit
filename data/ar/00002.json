{"title":"From Groovy to Java 8 ",
"content":"<p>Groovy developers will have a head-start in adopting the concepts and new language constructs offered by Java 8. Many of the enhancements offered in the upcoming version of Java are features that Groovy has offered for years. From new syntax for functional programming styles, to lambdas, collection streaming, and method references as first class citizens, Groovy developers will have an edge when writing Java code in the future. This article will focus on the commonalities between Groovy and Java 8, and will demonstrate how familiar Groovy concepts translate to Java 8.</p><p>We'll begin by discussing functional programming styles, how we use functional programming today in Groovy, and how the constructs of Java 8 offer a better functional programming style.</p><p>Closures are perhaps the best example of functional programming in Groovy. Under the hood, a closure in Groovy is really just an implementation of a functional interface. A functional interface is any interface that has only a single method to implement. By default, Groovy closures are an implementation of the functional Callable interface, implementing the 'call' method.</p><div class='clear'></div>                <pre>def closure = {<br>       'called'<br>}<br>assert closure instanceof java.util.concurrent.Callable<br>assert closure() == 'called'</pre><p>We can make Groovy implement other functional interfaces by type casting a closure.</p><pre>public interface Function {<br>         def apply();<br>} <br>def closure = {<br>        'applied'<br>} as Function<br>assert closure instanceof Function<br>assert closure.apply() == 'applied'</pre><p>Closures and functional programming translate well in Java 8. Functional interfaces are very important in the upcoming Java release because Java 8 offers implicit implementation of functional interfaces with the introduction of Lambda functions.</p>                        <div class='related_sponsors visible '>                                    <div class='related_editorial sponsored only1'>                <p class='title'>Related Vendor Content</p>                <div class='links'>                                                                                                                                                                                    <h3 title='' class='entrypdf f_vcrbottom' jsh='{&quot;id&quot;:2336,&quot;title&quot;:&quot;API Patterns for Cloud &amp; Mobile&quot;}'>                            <a href='http://www.infoq.com/vendorcontent/show.action?vcr=2336&amp;utm_source=infoq&amp;utm_medium=VCR&amp;utm_campaign=vcr_articles_click' target='_blank'>                                API Patterns for Cloud &amp; Mobile                            </a>                        </h3>                                                                                                                        <h3 title='' class='entrypdf f_vcrbottom' jsh='{&quot;id&quot;:2338,&quot;title&quot;:&quot;The Rise of the Composite API Platform, a ¡®Best-of-Breed¡¯ API Management Solution&quot;}'>                            <a href='http://www.infoq.com/vendorcontent/show.action?vcr=2338&amp;utm_source=infoq&amp;utm_medium=VCR&amp;utm_campaign=vcr_articles_click' target='_blank'>                                The Rise of the Composite API Platform, a ¡®Best-of-Breed¡¯ API Management Solution                            </a>                        </h3>                                                                                                                        <h3 title='' class='entrydemo f_vcrbottom' jsh='{&quot;id&quot;:2329,&quot;title&quot;:&quot;Everything You Need To Know About Graph Databases ¨C View Introductory Video&quot;}'>                            <a href='http://www.infoq.com/vendorcontent/show.action?vcr=2329&amp;utm_source=infoq&amp;utm_medium=VCR&amp;utm_campaign=vcr_articles_click' target='_blank'>                                Everything You Need To Know About Graph Databases ¨C View Introductory Video                            </a>                        </h3>                                                                                                                        <h3 title='' class='entrypdf f_vcrbottom' jsh='{&quot;id&quot;:2337,&quot;title&quot;:&quot;A Unified Mobile Architecture for the Modern Data Center&quot;}'>                            <a href='http://www.infoq.com/vendorcontent/show.action?vcr=2337&amp;utm_source=infoq&amp;utm_medium=VCR&amp;utm_campaign=vcr_articles_click' target='_blank'>                                A Unified Mobile Architecture for the Modern Data Center                            </a>                        </h3>                                                                                                                        <h3 title='' class='entrypdf f_vcrbottom' jsh='{&quot;id&quot;:2264,&quot;title&quot;:&quot;HTML5 Usage Patterns - Results from 2013 Global Developer Survey&quot;}'>                            <a href='http://www.infoq.com/vendorcontent/show.action?vcr=2264&amp;utm_source=infoq&amp;utm_medium=VCR&amp;utm_campaign=vcr_articles_click'>                                HTML5 Usage Patterns - Results from 2013 Global Developer Survey                            </a>                        </h3>                                                                                                                                                    <div class='clear'></div>                </div>            </div>                                        <div class='clear'></div>    </div>                       <p>Lambda functions can be thought of, and used, in the same way as closures in Groovy. Implementing a callable interface in Java 8 offers similar simplicity to closures in Groovy.</p><pre>Callable callable = () -&gt; 'called';<br>assert callable.call() == 'called';</pre><p>It's important to also note that single-line lambda functions in Java 8 offer implicit return statements, a concept shared with Groovy.</p><p>In the future, Groovy will also offer an implicit implementation of Single Abstract Methods for closures similar to those offered by Java 8. This feature gives closures the ability to leverage instance properties and methods without fully deriving a concrete subclass.</p><pre>abstract class WebFlowScope {<br>       private static final Map scopeMap = [:]<br>       abstract def getAttribute(def name);<br>       public def put(key, val) {<br>               scopeMap[key] = val<br>               getAttribute(key)<br>       } <br>       protected Map getScope() {<br>              scopeMap<br>       }<br>} <br>WebFlowScope closure = { name -&gt;<br>       'edited_${scope[name]}'<br>}<br>assert closure instanceof WebFlowScope<br>assert closure.put('attribute', 'val') == 'edited_val'</pre><p>In Java 8, functional interfaces with interface default methods offer a near approximation of this same concept. Interface default methods are a new concept in Java. They were conceived to allow improvements to core APIs without violating contracts for implementations that were built on prior versions of Java.</p><p>Lambda functions will also have access to default methods of the interface to which they are coerced. This means that robust APIs can be built directly into an interface, giving features to application developers without changing the nature of the type, or the contract in which that type may be used.</p><pre>public interface WebFlowScope {<br>        static final Map scopeMap = new HashMap();<br>        Object getAttribute(Object key);<br>        default public Object put(Object key, Object val) {<br>                scopeMap.put(key, val);<br>                return getAttribute(key);<br>        }<br>        default Map getScope() {<br>                return scopeMap;<br>        }<br>}<br>static final WebFlowScope scope = (Object key) -&gt; 'edited_' + scope.getScope().get(key);<br>assert scope.put('attribute', 'val') == 'val';</pre><p>Interface default methods in Java 8 can also help us implement features of Groovy such as memoization and trampolining. Memoization can be implemented simply by creating a functional interface with an interface default method to deterministically compute a result or retrieve the result from cache.</p><pre>public interface MemoizedFunction&lt;T, R&gt; {<br>  static final Map cache = new HashMap();<br>  R calc(T t);<br>  public default R apply(T t) {<br>    if (!cache.containsKey(t)) {<br>        cache.put(t, calc(t));<br>    }<br>    return (R)cache.get(t);<br>  }<br>}<br>static final MemoizedFunction&lt;Integer, Integer&gt; fib = (Integer n) -&gt; {<br>  if (n == 0 || n == 1) return n;<br>  return fib.apply(n - 1)+fib.apply(n-2);};<br>assert fib.apply(20) == 6765;</pre><p>Similarly, we can utilize interface default methods to develop a Trampoline implementation in Java 8. Trampolining in Groovy is a strategy of recursion that won't overwhelm Java's call stack, and is a very useful feature of Groovy when deep recursion is necessary.</p><pre>interface TrampolineFunction&lt;T, R&gt; {<br>   R apply(T...obj);<br>public default Object trampoline(T...objs) {<br>  Object result = apply(objs);<br>  if (!(result instanceof TrampolineFunction)) {<br>     return result;<br>  } else {<br>     return this;<br>  }<br> }<br>}<br>// Wrap the call in a TrampolineFunction so that we can avoid StackOverflowError<br>static TrampolineFunction&lt;Integer, Object&gt; fibTrampoline = (Integer...objs) -&gt; {<br>  Integer n = objs[0];<br>  Integer a = objs.length &gt;= 2 ? objs[1] : 0;<br>  Integer b = objs.length &gt;= 3 ? objs[2] : 1;<br>  if (n == 0) return a;<br>  else return fibTrampoline.trampoline(n-1, b, a+b);<br>};</pre><p>Beyond basic features of closures, and the more advanced features of Memoization and Trampolining, some of the most practical and useful features that Groovy has to offer are related to the language's extensions to the Collections API. In Groovy, we can leverage these extensions to shortcut writing operations against lists by using the 'each' method.</p><pre>def list = [1, 2, 3, 4]<br>list.each { item -&gt;<br>        println item<br>} </pre><p>Java 8 introduces a concept similar to Groovy for iterating a collection, making available a 'forEach' method, which replaces the conventional manner of iterating a list.</p><pre>List&lt;Integer&gt; list = new ArrayList&lt;&gt;();<br>list.add(1);<br>list.add(2);<br>list.add(3);<br>list.add(4);<br>list.forEach( (Integer item) -&gt; System.out.println(item); );</pre><p>In addition to simplified list iteration, Groovy gives application developers a variety of other shortcuts when working with lists. The 'collect' method, for example, is the shorthand for mapping list elements to new types or values, and collecting the results into a new list.</p><pre>def list = [1, 2, 3, 4]<br>def newList = list.collect { n -&gt; n * 5 }<br>assert newList == [5, 10, 15, 20]</pre><p>Groovy's implementation of 'collect' passes the mapper as an argument to the collect method, whilst Java 8 offers a slightly more verbose implementation. Using the Stream API, developers can accomplish the same mapping and collecting strategy by calling the 'map' method on the list's 'stream' component, and then calling the 'collect' method from the stream that is returned from the mapping step. The Stream API gives developers the ability to fluently chain operations against the list.</p><pre>List&lt;Integer&gt; list = new ArrayList&lt;&gt;();<br>list.add(1);<br>list.add(2);<br>list.add(3);<br>list.add(4);<br>List&lt;Integer&gt; newList = list.stream().map((Integer n) -&gt; n * 5).collect(Collectors.toList());<br>assert newList.get(0) == 5 &amp;&amp; newList.get(1) == 10 &amp;&amp; newList.get(2) == 15 &amp;&amp; newList.get(3) == 20;</pre><p>Groovy also gives developers shortcuts for filtering lists using the 'findAll' method.</p><pre>def emails = ['danielpwoods@gmail.com', 'nemnesic@gmail.com', 'daniel.woods@objectpartners.com', 'nemnesic@nemnesic.com']<br>def gmails = emails.findAll { it.endsWith('@gmail.com') }<br>assert gmails = ['danielpwoods@gmail.com', 'nemnesic@gmail.com']</pre><p>Similarly, Java 8 developers can filter a list with the Stream API.</p><pre>List&lt;String&gt; emails = new ArrayList&lt;&gt;();<br>emails.add('danielpwoods@gmail.com');<br>emails.add('nemnesic@gmail.com');<br>emails.add('daniel.woods@objectpartners.com');<br>emails.add('nemnesic@nemnesic.com');<br>List&lt;String&gt; gmails = emails.stream().filter( (String email) -&gt; email.endsWith('@gmail.com') ).collect(Collectors.toList());<br>assert gmails.get(0) == 'danielpwoods@gmail.com' &amp;&amp; gmails.get(1) == 'nemnesic@gmail.com';</pre><p>The Groovy Collections API extensions make it easy to sort lists by giving Collections a 'sort' method. The 'sort' method will also take a closure that will be cast to a comparator during list sorting if special sorting logic is required. Additionally, if simply reversing the order of a list is necessary, the 'reverse' method can be called and the order is swapped.</p><pre>def list = [2, 3, 4, 1]<br>assert list.sort() == [1, 2, 3, 4]<br>assert list.sort { a, b -&gt; a-b &lt;=&gt; b } == [1, 4, 3, 2]<br>assert list.reverse() == [2, 3, 4, 1]</pre><p>Working again with Java 8's Stream API, we can sort a list using the 'sorted' method, and collect those results using the 'toList' Collector. The 'sorted' method will optionally take a functional argument (such as a Lambda function) as a comparator, so special sorting logic and reversing the list items are operations easily achieved.</p><pre>List&lt;Integer&gt; list = new ArrayList&lt;&gt;();<br>list.add(2);<br>list.add(3);<br>list.add(4);<br>list.add(1);<br>list = list.stream().sorted().collect(Collectors.toList());<br>assert list.get(0) == 1 &amp;&amp; list.get(3) == 4;<br>list = list.stream().sorted((Integer a, Integer b) -&gt; Integer.valueOf(a-b).compareTo(b)).collect(Collectors.toList());<br>assert list.get(0) == 1 &amp;&amp; list.get(1) == 4 &amp;&amp; list.get(2) == 3 &amp;&amp; list.get(3) == 2;<br>list = list.stream().sorted((Integer a, Integer b) -&gt; b.compareTo(a)).collect(Collectors.toList());<br>assert list.get(0) == 2 &amp;&amp; list.get(3) == 1;</pre><p>When using fluent APIs, like list streaming, it can quickly become unmaintainable to try to handle all of the processing inside of a closure or Lambda function. It may make sense, in those cases, to delegate the processing to a method that is specifically suited for that unit of work.</p><p>In Groovy, we've been able to accomplish this by passing method references into functions. Once a method is referenced using the '.&amp;' operator, it is coerced to a closure and can be passed to another method as an argument. Inherently, this affords flexibility in implementation, since the processing code can be introduced from external sources. Developers can now logically organize processing methods, and achieve a more maintainable and sustainable application architecture.</p><pre>def modifier(String item) {<br>  'edited_${item}'<br>}<br>def list = ['item1', 'item2', 'item3']<br>assert list.collect(this.&amp;modifier) == ['edited_item1', 'edited_item2', 'edited_item3']</pre><p>Developers in Java 8 will be afforded the same flexibilities by making use of the '::' operator to get a reference to a method.</p><pre>List&lt;String&gt; strings = new ArrayList&lt;&gt;();<br>strings.add('item1');<br>strings.add('item2');<br>strings.add('item3');<br>strings = strings.stream().map(Helpers::modifier).collect(Collectors.toList());<br>assert 'edited_item1'.equals(strings.get(0));<br>assert 'edited_item2'.equals(strings.get(1));<br>assert 'edited_item3'.equals(strings.get(2));</pre><p>Method references can be passed as arguments to any method that requires a functional interface. In turn, the method reference will take the form of the functional interface, and can be treated as such.</p><pre>public interface MyFunctionalInterface {<br>  boolean apply();<br>}<br>void caller(MyFunctionalInterface functionalInterface) {<br>  assert functionalInterface.apply();<br>}<br>boolean myTrueMethod() {<br>  return true;<br>}<br>caller(Streaming::myTrueMethod);</pre><p>In Java 8, library developers can make changes to interface contracts without consumers having to update the way they interface with the library.</p><p>The seamless translation of concepts and programming styles from Groovy to Java 8 is an important bridge between the two languages. Groovy was adopted so heavily in the JVM space because of its inherent flexibilities and improvements to existing Java APIs. With a lot of these improvements taking root in Java 8, it means that the similarities between the two languages are beginning to outweigh the differences, a fact that this article intended to outline. To that end, experienced Groovy developers will have a much smaller learning curve when learning and adapting to the new APIs, features, and concepts that will be introduced to the Java ecosystem with Java 8.</p>"
}